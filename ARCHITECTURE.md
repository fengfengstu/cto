# 🏗️ 系统架构设计文档

## 概述

本项目是一个基于 **金字塔理论** 和 **MECE 法则** 的 AI 图像生成提示词变奏系统，旨在帮助用户结构化地生成和优化 AI 绘画提示词。

---

## 核心设计原则

### 1. 金字塔理论（Pyramid Principle）

金字塔理论强调从上至下的结构化思维：

```
                    [核心创意]
                        |
        ┌───────┬───────┼───────┬───────┬───────┐
        |       |       |       |       |       |
      主体层  风格层  环境层  技术层  氛围层  创新层
        |       |       |       |       |       |
     [子维度] [子维度] [子维度] [子维度] [子维度] [子维度]
        |       |       |       |       |       |
     [元素]   [元素]   [元素]   [元素]   [元素]   [元素]
```

**层次结构**：
- **顶层**：核心创意（用户想要表达的主题）
- **一级维度**：6 大维度（主体、风格、环境、技术、氛围、创新）
- **二级维度**：每个一级维度下的子维度（如主体层 → 主体类型、主体状态等）
- **底层**：具体可选元素（如主体类型 → 人物 → 单人、双人等）

### 2. MECE 法则（Mutually Exclusive, Collectively Exhaustive）

**相互独立（ME）**：
- 六大维度互不重叠，避免概念混淆
- 主体层：描述「什么」
- 风格层：描述「如何表现」
- 环境层：描述「在哪里」
- 技术层：描述「技术参数」
- 氛围层：描述「感觉如何」
- 创新层：描述「突破创新」

**完全穷尽（CE）**：
- 覆盖 AI 图像生成的所有关键要素
- 从具象到抽象，从基础到创新
- 确保不遗漏任何重要维度

---

## 系统架构

### 模块划分

```
┌─────────────────────────────────────────────────┐
│              用户交互层                          │
│  ┌──────────────┐         ┌──────────────┐    │
│  │  Web界面     │         │  CLI工具     │    │
│  │  (app.py)    │         │  (cli.py)    │    │
│  └──────────────┘         └──────────────┘    │
└─────────────────────────────────────────────────┘
                    │
                    ↓
┌─────────────────────────────────────────────────┐
│              业务逻辑层                          │
│         ┌────────────────────────┐              │
│         │   PromptGenerator      │              │
│         │  (prompt_generator.py) │              │
│         └────────────────────────┘              │
│          • 提示词生成                            │
│          • 变奏策略实现                          │
│          • 提示词分析                            │
│          • 完整方案生成                          │
└─────────────────────────────────────────────────┘
                    │
                    ↓
┌─────────────────────────────────────────────────┐
│              数据层                              │
│         ┌────────────────────────┐              │
│         │   PROMPT_PYRAMID       │              │
│         │  (prompt_pyramid.py)   │              │
│         └────────────────────────┘              │
│          • 金字塔结构定义                        │
│          • 变奏策略定义                          │
│          • 质量词库                              │
│          • 负向提示词库                          │
└─────────────────────────────────────────────────┘
```

---

## 核心数据结构

### 1. 金字塔结构（PROMPT_PYRAMID）

```python
PROMPT_PYRAMID = {
    "名称": "AI图像生成提示词金字塔",
    "描述": "按照MECE法则构建的完整提示词变奏体系",
    "结构": {
        "一级维度": {
            "1.主体层": {
                "描述": "描述图像的核心对象和内容",
                "子维度": {
                    "1.1.主体类型": {
                        "人物": [...],
                        "动物": [...],
                        ...
                    },
                    "1.2.主体状态": {...},
                    ...
                }
            },
            "2.风格层": {...},
            ...
        }
    }
}
```

**设计特点**：
- 多层嵌套字典结构
- 从抽象到具体的层次递进
- 易于扩展和维护

### 2. 变奏策略（VARIATION_STRATEGIES）

```python
VARIATION_STRATEGIES = {
    "变奏策略": {
        "1.单维度变奏": {
            "描述": "在一个维度内进行变化",
            "方法": [...]
        },
        ...
    }
}
```

---

## 核心算法

### 1. 随机提示词生成算法

```python
def generate_random_prompt(dimensions_count=4):
    1. 从六大维度中随机选择 N 个维度
    2. 对每个维度：
       a. 随机选择一个子维度
       b. 随机选择一个类别
       c. 随机选择一个元素
    3. 组合所有元素 + 质量词
    4. 返回完整提示词
```

**时间复杂度**：O(n)，n = dimensions_count

### 2. 单维度变奏算法

```python
def generate_single_dimension_variations(base, count):
    1. 随机选择一个维度
    2. 从该维度随机选择元素
    3. 将新元素追加到基础提示词
    4. 重复 count 次
```

### 3. 跨维度组合算法

```python
def generate_cross_dimension_variations(base, count):
    1. 随机选择 2-3 个维度
    2. 从每个维度随机选择元素
    3. 组合所有元素，追加到基础提示词
    4. 重复 count 次
```

### 4. 对比变奏算法

```python
def generate_contrast_variations(base, count):
    预定义对比组：
      - (古代, 未来)
      - (自然, 人造)
      - (明亮, 黑暗)
      ...
    
    1. 随机选择一个对比组
    2. 从对比组中选择一个元素
    3. 生成变奏
```

### 5. 渐进变奏算法

```python
def generate_progressive_variations(base, count):
    预定义渐进序列：
      - [清晨, 上午, 正午, ...]
      - [完整, 破损, 废墟, ...]
      ...
    
    1. 选择一个渐进序列
    2. 按顺序生成 count 个变奏
```

### 6. 极端变奏算法

```python
def generate_extreme_variations(base, count):
    极端修饰词：
      - 极度夸张
      - 极简主义
      - 极致细节
      ...
    
    1. 随机选择极端修饰词
    2. 添加到基础提示词前面
```

### 7. 提示词分析算法

```python
def analyze_prompt(prompt):
    1. 遍历所有维度
    2. 对每个维度：
       a. 遍历所有子维度
       b. 遍历所有元素
       c. 检查元素是否在提示词中
       d. 如果存在，记录到识别结果
    3. 计算未覆盖的维度
    4. 为未覆盖维度生成补充建议
```

**时间复杂度**：O(m × n)
- m = 元素总数
- n = 提示词长度

**优化空间**：可使用 Trie 树或哈希表加速匹配

---

## 变奏策略详解

### 策略矩阵

| 策略名称 | 变化维度 | 变化程度 | 适用场景 |
|---------|---------|---------|---------|
| 单维度变奏 | 1个维度 | 小 | 微调优化 |
| 跨维度组合 | 2-3个维度 | 中 | 丰富细节 |
| 对比变奏 | 1个维度（对立元素） | 中-大 | 探索对比 |
| 渐进变奏 | 1个维度（序列） | 中 | 系列创作 |
| 极端变奏 | 1个维度（极致） | 大 | 突破常规 |
| 混合实验 | 2-4个维度（随机） | 大 | 创意探索 |

### 策略选择建议

```
用户需求 → 推荐策略

• 优化现有提示词 → 单维度变奏
• 增加描述丰富度 → 跨维度组合
• 探索不同风格 → 对比变奏
• 制作系列作品 → 渐进变奏
• 寻求突破创新 → 极端变奏
• 灵感探索 → 混合实验
```

---

## 扩展性设计

### 1. 维度扩展

添加新维度只需：

```python
"7.新维度层": {
    "描述": "新维度的说明",
    "子维度": {
        "7.1.子维度名": {
            "类别1": ["元素1", "元素2", ...],
            "类别2": [...],
        }
    }
}
```

### 2. 策略扩展

添加新策略只需：

```python
# 在 VARIATION_STRATEGIES 中添加
"7.新策略": {
    "描述": "策略说明",
    "方法": [...]
}

# 在 PromptGenerator 中实现
def _generate_new_strategy_variations(self, base, count):
    # 实现逻辑
    pass
```

### 3. 多语言支持

当前为全中文设计，支持多语言的方案：

```python
# 方案1：翻译字典
TRANSLATIONS = {
    "zh": {...},  # 中文
    "en": {...},  # 英文
    "ja": {...},  # 日文
}

# 方案2：国际化框架
from babel import Locale
```

---

## 性能优化

### 1. 缓存机制

```python
from functools import lru_cache

@lru_cache(maxsize=128)
def get_dimension_info(dimension):
    # 缓存维度信息
    pass
```

### 2. 批量生成优化

```python
# 避免重复随机选择
def generate_batch_prompts(count):
    # 预先生成随机数
    # 批量处理
    pass
```

### 3. 并行处理

```python
from concurrent.futures import ThreadPoolExecutor

def generate_variations_parallel(base, strategies, count):
    with ThreadPoolExecutor() as executor:
        futures = [
            executor.submit(generate_variations, base, s, count)
            for s in strategies
        ]
        return [f.result() for f in futures]
```

---

## 测试策略

### 1. 单元测试

```python
import unittest

class TestPromptGenerator(unittest.TestCase):
    def test_get_all_dimensions(self):
        # 测试维度获取
        pass
    
    def test_generate_random_prompt(self):
        # 测试随机生成
        pass
    
    def test_generate_variations(self):
        # 测试变奏生成
        pass
```

### 2. 集成测试

- 测试完整工作流
- 测试各模块协作
- 测试边界情况

### 3. 用户测试

- 可用性测试
- A/B 测试不同策略效果
- 收集用户反馈

---

## 部署方案

### 1. 本地部署

```bash
# 安装依赖
pip install -r requirements.txt

# 启动 Web 应用
streamlit run app.py

# 使用 CLI 工具
python cli.py --help
```

### 2. Docker 部署

```dockerfile
FROM python:3.9-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

CMD ["streamlit", "run", "app.py", "--server.port=8501"]
```

### 3. 云服务部署

- **Streamlit Cloud**：直接连接 GitHub 仓库
- **Heroku**：使用 Procfile
- **AWS/Azure/GCP**：使用容器服务

---

## 未来优化方向

### 1. AI 增强

- 使用 GPT 模型优化提示词组合
- 基于用户反馈的强化学习
- 自动识别提示词中的语义元素

### 2. 社区功能

- 用户分享优秀提示词
- 提示词评分和收藏
- 社区投票和推荐

### 3. 高级功能

- 提示词版本管理
- 批量生成和导出
- 与 AI 绘画工具集成
- 提示词效果预测

### 4. 数据分析

- 统计最受欢迎的维度组合
- 分析成功提示词的模式
- 提供个性化推荐

---

## 总结

本系统通过 **金字塔理论** 实现层次化结构，通过 **MECE 法则** 保证完整性和独立性，为用户提供了一个科学、系统、高效的 AI 图像生成提示词创作工具。

系统具有良好的扩展性、可维护性和性能，可根据实际需求灵活调整和优化。
